//package com.example.practice.codeforces; import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.ArrayDeque;import java.util.ArrayList;import java.util.Arrays;import java.util.StringTokenizer; public class Solution {    public static void main(String [] args) throws IOException {        // Use BufferedReader rather than RandomAccessFile; it's much faster        final BufferedReader input = new BufferedReader(new InputStreamReader(System.in));        final PrintWriter out = new PrintWriter(System.out);        // input file name goes above        int Q = Integer.parseInt(input.readLine());        while (Q > 0) {            StringTokenizer st = new StringTokenizer(input.readLine());            final int n = Integer.parseInt(st.nextToken()), m = Integer.parseInt(st.nextToken());            final char[][] g = new char[n][];            for (int i=0;i<n;++i) {                g[i] = input.readLine().toCharArray();            }            out.println(calc(n, m, g));            --Q;//1        }        out.close();       // close the output file    }     private static int calc(final int m, final int n, final char[][] g) {        int res = check(m, n, g);        if (res <= 1) {            return res;        }        for (int i=0;i<m;++i) {            for (int a=0,b=n-1;a<b;++a,--b) {                final char tem = g[i][a];                g[i][a] = g[i][b];                g[i][b] = tem;            }        }        res = Math.min(res, check(m, n, g));        for (int j=0;j<n;++j) {            for (int a=0,b=m-1;a<b;++a,--b) {                final char tem = g[a][j];                g[a][j] = g[b][j];                g[b][j] = tem;            }        }        res = Math.min(res, check(m, n, g));        for (int i=0;i<m;++i) {            for (int a=0,b=n-1;a<b;++a,--b) {                final char tem = g[i][a];                g[i][a] = g[i][b];                g[i][b] = tem;            }        }        res = Math.min(res, check(m, n, g));        return res;    }     private static int check(final int m, final int n, final char[][] g) {        final int MODE1 = 1000000007, MODE2 = 998244353, M = 26;        final long[] base = new long[]{1, 1};        final long[][] vs = new long[m][], vs2 = new long[m][];        final int[][] cs = new int[2][m];        for (int i=0;i<m;++i) {            vs[i] = new long[]{0, 0};            vs2[i] = new long[]{0, 0};        }        int res = m * n * 3;        for (int i=0;i<n;++i) {            for (int j=0;j<m;++j) {                final int ch = g[j][i] - 'a';                vs[j][0] = (vs[j][0] * M + ch) % MODE1;                vs[j][1] = (vs[j][1] * M + ch) % MODE2;                vs2[j][0] = (vs2[j][0] + ch * base[0]) % MODE1;                vs2[j][1] = (vs2[j][1] + ch * base[1]) % MODE2;            }            base[0] = base[0] * M % MODE1;            base[1] = base[1] * M % MODE2;            int p = 0, c = Arrays.equals(vs[0], vs2[0]) ? 1 : 0, mx = c;            cs[0][0] = c;            for (int j=1;j<m;++j) {                if (c > j - p) {                    final int pre = p - (j - p) + 1, l = j - p;                    if (cs[1][pre] + l == c) {                        cs[1][j] = c - l;                        int b = p + c, a = j - (b - j) - 1;                        while (a >= 0 && b < m && Arrays.equals(vs[a], vs2[b])) {                            a--;                            b++;                            cs[1][j]++;                        }                    } else {                        cs[1][j] = Math.min(cs[1][pre], c - l);                    }                } else {                    cs[1][j] = 0;                    int a = j - 1, b = j;                    while (a >= 0 && b < m && Arrays.equals(vs[a], vs2[b])) {                        a--;                        b++;                        cs[1][j]++;                    }                }                if (cs[1][j] == j) {                    mx = j + j;                }                if (c > j - p) {                    final int pre = p - (j - p), l = j - p;                    if (cs[0][pre] + l == c) {                        cs[0][j] = c - l;                        int b = p + c, a = j - (b - j);                        while (a >= 0 && b < m && Arrays.equals(vs[a], vs2[b])) {                            a--;                            b++;                            cs[0][j]++;                        }                    } else {                        cs[0][j] = Math.min(cs[0][pre], c - l);                    }                } else {                    cs[0][j] = 0;                    int a = j, b = j;                    while (a >= 0 && b < m && Arrays.equals(vs[a], vs2[b])) {                        a--;                        b++;                        cs[0][j]++;                    }                }                if (cs[0][j] == j + 1) {                    mx = j + j + 1;                }                if (cs[0][j] > c) {                    c = cs[0][j];                    p = j;                }            }            if (mx > 0) {                int v = 0;                if (m > mx) {                    v = (m - mx) * (i + 1);                    if (i < n - 1) {                        v += mx * (n - 1 - i) + (m - mx) * (n - 1 - i) * 3;                    }                } else if (i < n - 1) {                    v = mx * (n - 1 - i);                }                res = Math.min(res, v);            }        }        return res;    }     private static void printArray(long[] ns, final PrintWriter out){        for (int i=0;i<ns.length;++i){            out.print(ns[i]);            if (i+1<ns.length)out.print(" ");            else out.println();        }    }     private static void printArrayInt(int[] ns, final PrintWriter out){        for (int i=0;i<ns.length;++i){            out.print(ns[i]);            if (i+1<ns.length)out.print(" ");            else out.println();        }    }     private static void printArrayVertical(long[] ns, final PrintWriter out){        for (long a : ns){            out.println(a);        }    }     private static void printArrayVerticalInt(int[] ns, final PrintWriter out){        for (int a : ns){            out.println(a);        }    }     private static void printArray2D(long[][] ns, final int len, final PrintWriter out){        int cnt = 0;        for (long[] kk : ns){            cnt++;            if (cnt > len)break;            for (int i=0;i<kk.length;++i){                out.print(kk[i]);                if (i+1<kk.length)out.print(" ");                else out.println();            }        }    }     private static void printArray2DInt(int[][] ns, final int len, final PrintWriter out){        int cnt = 0;        for (int[] kk : ns){            cnt++;            if (cnt > len)break;            for (int i=0;i<kk.length;++i){                out.print(kk[i]);                if (i+1<kk.length)out.print(" ");                else out.println();            }        }    }     private static long[] readArray(final int n, final BufferedReader input) throws IOException{        long[] ns = new long[n];        StringTokenizer st = new StringTokenizer(input.readLine());        for (int i=0;i<n;++i){            ns[i] = Long.parseLong(st.nextToken());        }        return ns;    }     private static int[] readArrayInt(final int n, final BufferedReader input) throws IOException{        int[] ns = new int[n];        StringTokenizer st = new StringTokenizer(input.readLine());        for (int i=0;i<n;++i){            ns[i] = Integer.parseInt(st.nextToken());        }        return ns;    }     private static long[] readArrayVertical(final int n, final BufferedReader input) throws IOException{        long[] ns = new long[n];        for (int i=0;i<n;++i){            ns[i] = Long.parseLong(input.readLine());        }        return ns;    }     private static int[] readArrayVerticalInt(final int n, final BufferedReader input) throws IOException{        int[] ns = new int[n];        for (int i=0;i<n;++i){            ns[i] = Integer.parseInt(input.readLine());        }        return ns;    }     private static long[][] readArray2D(final int n, final int len, final BufferedReader input) throws IOException{        long[][] ns = new long[len][];        for (int i=0;i<n;++i){            StringTokenizer st = new StringTokenizer(input.readLine());            ArrayList<Long> al = new ArrayList<>();            while (st.hasMoreTokens()){                al.add(Long.parseLong(st.nextToken()));            }            long[] kk = new long[al.size()];            for (int j=0;j<kk.length;++j){                kk[j] = al.get(j);            }            ns[i] = kk;        }        return ns;    }     private static int[][] readArray2DInt(final int n, final int len, final BufferedReader input) throws IOException{        int[][] ns = new int[len][];        for (int i=0;i<n;++i){            StringTokenizer st = new StringTokenizer(input.readLine());            ArrayList<Integer> al = new ArrayList<>();            while (st.hasMoreTokens()){                al.add(Integer.parseInt(st.nextToken()));            }            int[] kk = new int[al.size()];            for (int j=0;j<kk.length;++j){                kk[j] = al.get(j);            }            ns[i] = kk;        }        return ns;    }     private static long[][] readArray2DWithIdx(final int n, final int m, final BufferedReader input) throws IOException{        long[][] ns = new long[n][m+1];        for (int i=0;i<n;++i){            StringTokenizer st = new StringTokenizer(input.readLine());            for (int j=0;j<m;++j){                ns[i][j] = Long.parseLong(st.nextToken());            }            ns[i][m] = i;        }        return ns;    }     private static int[][] readArray2DIntWithIdx(final int n, final int m, final BufferedReader input) throws IOException{        int[][] ns = new int[n][m+1];        for (int i=0;i<n;++i){            StringTokenizer st = new StringTokenizer(input.readLine());            for (int j=0;j<m;++j){                ns[i][j] = Integer.parseInt(st.nextToken());            }            ns[i][m] = i;        }        return ns;    }     private static String[] readArrayString(final int n, final BufferedReader input) throws IOException{        String[] res = new String[n];        for (int i=0;i<n;++i){            res[i] = input.readLine();        }        return res;    }     private static int GCD(int x, int y){        if (x > y)return GCD(y, x);        if (x==0)return y;        return GCD(y%x, x);    }     private static long GCD(long x, long y){        if (x > y)return GCD(y, x);        if (x==0)return y;        return GCD(y%x, x);    }     private static ArrayList<int[]>[] convertToGraphUnDirectWithWeight(final int n, final int[][] es){        ArrayList<int[]>[] als = new ArrayList[n+1];        for (int i=0;i<=n;++i){            als[i] = new ArrayList<>();        }        for (int[] e : es){            als[e[0]].add(Arrays.copyOfRange(e, 1, e.length));            final int[] kk = Arrays.copyOfRange(e, 1, e.length);            kk[0] = e[0];            als[e[1]].add(kk);        }        return als;    }     private static ArrayList<int[]>[] convertToGraphDirectWithWeight(final int n, final int[][] es){        ArrayList<int[]>[] als = new ArrayList[n+1];        for (int i=0;i<=n;++i){            als[i] = new ArrayList<>();        }        for (int[] e : es){            als[e[0]].add(Arrays.copyOfRange(e, 1, e.length));        }        return als;    }     private static ArrayList<int[]>[] convertToGraphUnDirect(final int n, final int[][] es){        ArrayList<int[]>[] als = new ArrayList[n+1];        for (int i=0;i<=n;++i){            als[i] = new ArrayList<>();        }        int p = 0;        for (int[] e : es){            als[e[0]].add(new int[]{e[1], p});            als[e[1]].add(new int[]{e[0], p++});        }        return als;    }     private static ArrayList<int[]>[] convertToGraphDirect(final int n, final int[][] es){        ArrayList<int[]>[] als = new ArrayList[n+1];        for (int i=0;i<=n;++i){            als[i] = new ArrayList<>();        }        int p = 0;        for (int[] e : es){            als[e[0]].add(new int[]{e[1], p++});        }        return als;    }     private static int find(final int[] rd, int idx){        while (idx != rd[idx]){            rd[idx] = rd[rd[idx]];            idx = rd[idx];        }        return idx;    }     private static long pow(final long a, final long x, final int MODE){        if (x==0)return 1L;        long res = pow(a, x>>1, MODE);        res = res * res % MODE;        if ((x&1) == 1){            res = res * a % MODE;        }        return res;    }     private static long[][] getCombArray(final int n, final int k, final int MODE) {        final long[][] res = new long[n+1][k+1];        res[0][0] = 1L;        for (int i=1;i<=n;++i) {            res[i][0] = 1L;            if (i <= k) {                res[i][i] = 1L;            }            for (int j=1;j<i && j<=k;++j) {                res[i][j] = (res[i-1][j] + res[i-1][j-1]) % MODE;            }        }        return res;    }     private static long multiInv(final int n, final int MODE) {        return pow(n, MODE - 2, MODE);    }     private static long[] getFac(final int n, final int MODE) {        final long[] res = new long[n+1];        res[0] = 1;        for (int i=1;i<=n;++i) {            res[i] = i * res[i-1] % MODE;        }        return res;    }     private static long[] getFacInv(final int n, final int MODE) {        final long[] res = new long[n+1];        res[1] = 1;        for (int i=2;i<=n;++i) {            res[i] = (MODE - MODE / i) * res[MODE % i] % MODE;        }        for (int i=2;i<=n;++i) {            res[i] = res[i] * res[i-1] % MODE;        }        return res;    }     private static long comb(final int n, final int c, final long[] fc,                             final long[] inv, final int MODE) {        if (c == 0 || c == n)return 1L;        return fc[n] * inv[c] % MODE * inv[n-c] % MODE;    }     private static int[] getMobius(final int n) {        final int[] res = new int[n+1], pm = new int[n+1], sta = new int[n+1];        int p = 0;        res[1] = 1;        for (int i=2;i<=n;++i) {            if (pm[i] == 0){                pm[i] = i;                sta[p++] = i;                res[i] = -1;            }            for (int j=0;j<p;++j) {                final int num = sta[j] * i;                if (sta[j] > pm[i] || num > n) {                    break;                }                pm[num] = sta[j];                if (pm[i] == sta[j]) {                    res[num] = 0;                } else {                    res[num] = -res[i];                }            }        }        return res;    }     private static int[][] getKMP(final char[] cc) {        final int n = cc.length;        final int[][] res = new int[2][n];        res[0][0] = res[1][0] = -1;        int cur = -1;        for (int i=1;i<n;++i) {            ++cur;            if (cc[cur] != cc[i]) {                res[0][i] = cur;                while (cur >= 0 && cc[cur] != cc[i]) {                    cur = res[0][cur];                }            } else {                res[0][i] = res[0][cur];            }            res[1][i] = cur;        }        return res;    }     private static boolean[] getPrimeArray(final int n) {        boolean[] ps = new boolean[n+1];        for (int i=2;i*i<=n;++i){            if (!ps[i]) {                for (int j = i * i; j <= n; j += i) {                    ps[j] = true;                }            }        }        ps[0] = ps[1] = true;        return ps;    }     private static ArrayList<Integer> getPrimes(final int n, final boolean[] ps) {        final ArrayList<Integer> prime = new ArrayList<>();        for (int i=2;i<=n;++i){            if (!ps[i]){                prime.add(i);            }        }        return prime;    }     private static ArrayList<int[]> findAllMatch(final char[] cc, final char[] pt) {        final int[][] kmp = getKMP(pt);        final int n = cc.length, m = pt.length;        final ArrayList<int[]> res = new ArrayList<>();        for (int i=0,j=0;i<=n-(m-j);) {            if (cc[i] == pt[j]) {                i++;                j++;                if (j == m) {                    res.add(new int[]{i-m, i});                    if (kmp[1][m-1] < 0) {                        j = 0;                    }else {                        j = kmp[1][m-1] + 1;                    }                }            } else if (kmp[0][j] < 0) {                i++;                j = 0;            } else {                j = kmp[0][j];            }        }        return res;    }     private static int exGCD(final int a, final int b, final long[] x, final long[] y) {        if (b == 0){            x[0] = 1;            y[0] = 0;            return a;        }        final int d = exGCD(b, a % b, x, y);        long tem = x[0];        x[0] = y[0];        y[0] = tem - a / b * y[0];        return d;    }     private static int findRoot(ArrayList<Integer>[] als) {        if (als.length <= 10)return 1;        int res = 0;        ArrayDeque<Integer> ll = new ArrayDeque<>();        int[] rd = new int[als.length];        for (int i=1;i<als.length;++i){            if (als[i].size()==1){                ll.add(i);            }            rd[i] = als[i].size();        }        while (!ll.isEmpty()){            int k = ll.poll();            res = k;            for (int a : als[k]){                rd[a]--;                if (rd[a]==1){                    ll.add(a);                }            }        }        return res;    }     private static int findRoot2(ArrayList<int[]>[] als) {        if (als.length <= 10)return 1;        int res = 0;        ArrayDeque<Integer> ll = new ArrayDeque<>();        int[] rd = new int[als.length];        for (int i=1;i<als.length;++i){            if (als[i].size()==1){                ll.add(i);            }            rd[i] = als[i].size();        }        while (!ll.isEmpty()){            int k = ll.poll();            res = k;            for (int[] kk : als[k]){                rd[kk[0]]--;                if (rd[kk[0]]==1){                    ll.add(kk[0]);                }            }        }        return res;    }     static class SegTree{        long sum;        long diff;        int st;        int en;        int mid;        int val1;        int val2;        SegTree left;        SegTree right;        public SegTree(int l, int r, int d){            sum = diff = 0;            st = l;            en = r;            mid = (st + en) >> 1;            val1 = val2 = d;            if (st<en){                left = new SegTree(st, mid, d);                right = new SegTree(mid+1, en, d);            }else {                left = right = null;            }        }         public SegTree(int l, int r, int[] ns){            sum = diff = 0;            st = l;            en = r;            mid = (st + en) >> 1;            if (st==en){                val1 = val2 = ns[st];            }else {                left = new SegTree(l, mid, ns);                right = new SegTree(mid+1, r, ns);                val1 = Math.min(left.val1, right.val1);                val2 = Math.max(left.val2, right.val2);            }        }         void update(int idx, int v){            if (st==en){                val1 = val2 = v;            }else {                pushDown();                if (idx <= mid){                    left.update(idx, v);                }else {                    right.update(idx, v);                }                val1 = Math.min(left.val1, right.val1);                val2 = Math.max(left.val2, right.val2);            }        }         int getMin(int l, int r){            if (st==en || (l==st && r==en))return val1;            pushDown();            if (r<=mid){                return left.getMin(l, r);            }            if (l>mid){                return right.getMin(l, r);            }            return Math.min(left.getMin(l, mid), right.getMin(mid+1, r));        }         int getMax(int l, int r){            if (st==en || (l==st && r==en))return val2;            pushDown();            if (r<=mid){                return left.getMax(l, r);            }            if (l>mid){                return right.getMax(l, r);            }            return Math.max(left.getMax(l, mid), right.getMax(mid+1, r));        }         long rangeAdd(final int l, final int r, long d){            long res;            if (st==l && en==r){                res = (en-st+1) * d;                sum += res;                val1 += d;                val2 += d;                if (st < en) {                    this.diff += d;                }            }else {                pushDown();                if (r<=mid){                    res = left.rangeAdd(l, r, d);                    sum += res;                }else if (l>mid){                    res = right.rangeAdd(l, r, d);                    sum += res;                }else {                    res = left.rangeAdd(l, mid, d);                    res += right.rangeAdd(mid+1, r, d);                    sum += res;                }                val1 = Math.min(left.val1, right.val1);                val2 = Math.max(left.val2, right.val2);            }            return res;        }         long querySum(final int l, final int r){            pushDown();            long res;            if (st==l && en==r){                res = sum;            }else if (r<=mid){                res = left.querySum(l, r);            }else if (l>mid){                res = right.querySum(l, r);            }else {                res = left.querySum(l, mid);                res += right.querySum(mid+1, r);            }            return res;        }         private void pushDown(){            if (diff!=0 && st<en){                left.loadDiff(this.diff);                right.loadDiff(this.diff);                this.diff = 0;            }        }         private void loadDiff(final long d){            sum += d * (en-st+1);            val1 += d;            val2 += d;            if (st < en){                this.diff += d;            }        }    }     static class SparseTable{        int[][] minTable;        int[][] maxTable;        int[] log2;        int n;        public SparseTable(final int[] ns){            n = ns.length;            int m = 0, pre = 0;            while (1<<m < n){                m++;            }            m++;            minTable = new int[n][m];            maxTable = new int[n][m];            log2 = new int[n+1];            for (int i=0;i<n;++i){                minTable[i][0] = ns[i];                maxTable[i][0] = ns[i];                if ((1<<(pre+1)) == i+1){                    pre++;                }                log2[i+1] = pre;            }            for (int i=1;i<m;++i){                for (int j=0;j<n;++j){                    int r = Math.min(n-1, j+(1<<i)-1);                    if (r-(1<<(i-1))+1 <= j){                        minTable[j][i] = minTable[j][i-1];                        maxTable[j][i] = maxTable[j][i-1];                    }else {                        minTable[j][i] = Math.min(minTable[j][i-1], minTable[r-(1<<(i-1))+1][i-1]);                        maxTable[j][i] = Math.max(maxTable[j][i-1], maxTable[r-(1<<(i-1))+1][i-1]);                    }                }            }        }         int getMin(final int l, final int r){            int d = log2[r-l+1];            return Math.min(minTable[l][d], minTable[r-(1<<d)+1][d]);        }         int getMax(final int l, final int r){            int d = log2[r-l+1];            return Math.max(maxTable[l][d], maxTable[r-(1<<d)+1][d]);        }    }     static class BIT{        long[] ns;        public BIT(int n){            ns = new long[n];        }        void add(int idx, int v){            for (int i=idx; i<ns.length; i += -i & i){                ns[i] += v;            }        }        long get(int idx){            long res = 0;            for (int i=idx; i>0; i -= -i & i){                res += ns[i];            }            return res;        }        int getFloor(long v) {            int res = 0;            for (int i=Integer.highestOneBit(ns.length);i>0;i>>=1){                if (res+i < ns.length && ns[res+i] <= v){                    res += i;                    v -= ns[res];                }            }            return res;        }    }     static class NTT{        final int g;        final int mod;        final int M = 1000010;        private int[] rev;        public NTT(int a, int b){            mod = a;            g = b;            rev = new int[M+1];        }        private long pow(long a, int x){            long res = 1, a2 = a;            while (x > 0){                if ((x&1) == 1){                    res = res * a2 % mod;                }                x = x>>1;                a2 = a2 * a2 % mod;            }            return res;        }        private void ntt(long[] ns, final int len, final int type){            for (int i=0;i<len;++i){                if (i < rev[i]){                    long temp = ns[i];                    ns[i] = ns[rev[i]];                    ns[rev[i]] = temp;                }            }            for (int i=1;i<len;i=i<<1){                final long gn;                if (type != -1){                    gn = pow(g, (mod-1)/(i<<1));                }else {                    gn = pow(pow(g, (mod-1)/(i<<1)), mod-2);                }                for (int j=0;j<len;j+=(i<<1)){                    long gi = 1;                    for (int k=0;k<i;++k){                        final long x = ns[j+k], y = gi * ns[i+j+k] % mod;                        ns[j+k] = (x+y) < mod ? x+y : x+y-mod;                        ns[i+j+k] = x-y >= 0 ? x-y : x-y+mod;                        gi = gi * gn % mod;                    }                }            }            if (type == -1){                final long inv = pow(len, mod-2);                for (int i=0;i<len;++i){                    ns[i] = ns[i] * inv % mod;                }            }        }         public long[] multi(final int[] as){            long l1 = extend(as);            int len = 1, L = 0;            while (len <= l1+l1){                len = len << 1;                L++;            }            for (int i=0;i<len;++i){                rev[i] = (rev[i>>1] >> 1) | ((i & 1) << (L-1));            }            long[] xx = new long[len];            for (int i=0;i<as.length;++i){                xx[i] = as[i];            }            ntt(xx, len, 1);            for (int i=0;i<len;++i){                xx[i] = xx[i] * xx[i] % mod;            }            ntt(xx, len ,-1);            return xx;        }         public long[] multi(final int[] as, final int[] bs){            long l1 = extend(as), l2 = extend(bs);            int len = 1, L = 0;            while (len <= l1+l2){                len = len << 1;                L++;            }            for (int i=0;i<len;++i){                rev[i] = (rev[i>>1] >> 1) | ((i & 1) << (L-1));            }            long[] xx = new long[len], yy = new long[len];            for (int i=0;i<as.length;++i){                xx[i] = as[i];            }            for (int i=0;i<bs.length;++i){                yy[i] = bs[i];            }            ntt(xx, len, 1);            ntt(yy, len, 1);            for (int i=0;i<len;++i){                xx[i] = xx[i] * yy[i] % mod;            }            ntt(xx, len ,-1);            return xx;        }         private long extend(final int[] ns){            /*int len;            if (ns.length - (ns.length & (0-ns.length)) == 0){                len = ns.length;            }else {                len = 1;                while (len < ns.length){                    len = len << 1;                }            }            return len;*/            return ns.length;        }    }}