import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.UnknownHostException;import java.sql.SQLException;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Comparator;import java.util.HashMap;import java.util.HashSet;import java.util.LinkedList;import java.util.PriorityQueue;import java.util.Queue;import java.util.Set;import java.util.Stack;import java.util.StringTokenizer; public class Demo{	static class FastReader {        BufferedReader br;        StringTokenizer st;         public FastReader()        {            br = new BufferedReader(                new InputStreamReader(System.in));        }         String next()        {            while (st == null || !st.hasMoreElements()) {                try {                    st = new StringTokenizer(br.readLine());                }                catch (IOException e) {                    e.printStackTrace();                }            }            return st.nextToken();        }         int nextInt() { return Integer.parseInt(next()); }         long nextLong() { return Long.parseLong(next()); }         double nextDouble()        {            return Double.parseDouble(next());        }         String nextLine()        {            String str = "";            try {                str = br.readLine();            }            catch (IOException e) {                e.printStackTrace();            }            return str;        }    }		public static boolean isPalindrome(String str)	{		int i = 0, j = str.length() - 1;		         while (i < j)        {            if (str.charAt(i) != str.charAt(j))                return false;            i++;            j--;        }				return true;	}		public static long modularExpo(long a, long b, long mod)	{		a = a%mod;		long res = 1;				while(b > 0)		{			if((b&1) != 0)			{				res = (res*a)%mod;			}						a = (a*a)%mod;			b = b>>1;		}				return res;	}		public static long fastExpo(long a, long b)	{		long res = 1;				while(b > 0)		{			if( (b&1) != 0 )			{				res = res * a;			}			a = a*a;			b = b>>1;		}				return res;	}		public static long gcd (long a, long b) {	    if (b == 0)	        return a;	    else	        return gcd (b, a % b);	}		public static long lcm (long a, long b) {	    return a / gcd(a, b) * b;	}		public static double gcd (double a, double b) {	    if (b == 0)	        return a;	    else	        return gcd (b, a % b);	}		public static double lcm (double a, double b) {	    return a / gcd(a, b) * b;	}		static boolean isPrime(long n, long k)    {    if (n <= 1 || n == 4) return false;    if (n <= 3) return true;         while (k > 0)    {    	long a = 2 + (int)(Math.random() % (n - 4));             // Fermat's little theorem        if (modularExpo(a, n - 1, n) != 1)            return false;             k--;    }             return true;    }	    public static double findnthroot(double x, int n)    {    	double low, high;    	    	if(x >= 0 && x <= 1)    	{    		low = x;    		high = 1;    	}    	else    	{    		low = 1;     		high = x;    	}    	    	double epsilon = 0.00000001;    	    	double guess = (low+high)/2;    	    	while(Math.abs(Math.pow(guess, n) - x) >= epsilon )    	{    		if(Math.pow(guess, n) > x)    		{    			high = guess;    		}    		else    		{    			low = guess;    		}    		guess = (low + high)/2;    	}    	//    	System.out.println(String.format("%.4f", guess));    	return guess;    }        // Function to implement lower_bound    static int lower_bound(int arr[], int X)    {    	int mid;    	int N = arr.length;    	int low = 0;    	int high = N;     	while (low < high) {    		mid = low + (high - low) / 2;     		if (X <= arr[mid]) {    			high = mid;    		}     		else {    			low = mid + 1;    		}    	}     	if(low < N && arr[low] < X) {    	low++;    	}    	    	return low;    }        static long lower_bound(long arr[], long X)    {    	long mid;    	long N = arr.length;    	long low = 0;    	long high = N;     	while (low < high) {    		mid = low + (high - low) / 2;     		if (X <= arr[(int) mid]) {    			high = mid;    		}     		else {    			low = mid + 1;    		}    	}     	if(low < N && arr[(int) low] < X) {    	low++;    	}    	    	return low;    }        // Function to implement upper_bound    static int upper_bound(int arr[], int X)    {    	int mid;    	int N = arr.length;    	int low = 0;    	int high = N;     	while (low < high) {    		mid = low + (high - low) / 2;     		if (X >= arr[mid]) {    			low = mid + 1;    		}     		else {    			high = mid;    		}    	}     	if(low < N && arr[low] <= X) {    	low++;    	}     	return low;    }        static long upper_bound(long arr[], long X)    {    	long mid;    	long N = arr.length;    	long low = 0;    	long high = N;     	while (low < high) {    		mid = low + (high - low) / 2;     		if (X >= arr[(int) mid]) {    			low = mid + 1;    		}     		else {    			high = mid;    		}    	}     	if(low < N && arr[(int) low] <= X) {    	low++;    	}     	return low;    }        static int[] reverse(int a[])    {    	int n = a.length;        int i, k, t;        for (i = 0; i < n / 2; i++) {            t = a[i];            a[i] = a[n - i - 1];            a[n - i - 1] = t;        }          return a;    }        static char[] reverse(char a[])    {    	int n = a.length;        int i, k;        char t;        for (i = 0; i < n / 2; i++) {            t = a[i];            a[i] = a[n - i - 1];            a[n - i - 1] = t;        }        return a;    }        public static int mod(long s, int mOD) {		while (s < mOD) {			s = s + mOD;		}		return (int) (s % mOD);	}        public static boolean isSubstring(String s, String t){        int n = s.length();        int m = t.length();    	int count = 0;        boolean[] vis = new boolean[n];        int prev = -1;        for(int i = 0; i < m; i++){            for(int j = 0; j < n; j++){                if(t.charAt(i) == s.charAt(j) && !vis[j] && prev < j) {                    vis[j] = true;                    count++;                    prev = j;                    break;                }            }        }        return count == m;    }        public static int n;    public static int m;    public static int count;    public static char grid[][];    public static char grid_temp[][];    public static boolean vis[][];    public static int adj[][];    public static int di[] = {1,-1,0,0,1,-1,1,-1};    public static int dj[] = {0,0,1,-1,1,-1,-1,1};    public static int startx,starty,endx,endy;    public static ArrayList<Integer> path = new ArrayList<Integer>();    public static StringBuilder input1 = new StringBuilder();    public static ArrayList<ArrayList<Integer>> graph = new ArrayList<>();    public static boolean visited[];    public static int parent[];        public static Set<Long> primes()    {    	boolean[] p=new boolean[1000001];        p[0]=false;        p[1]=false;        p[2]=true;        for(int i=3;i<p.length;i+=2)p[i]=true;         for(int i=3;i<p.length;i+=2){            if(p[i]){                for(int j=3*i;j<p.length;j+=2*i)p[j]=false;            }        }        Set<Long> hs=new HashSet<>();        hs.add(4L);        for(int i=3;i<p.length;i+=2){            if(p[i])hs.add((long)i*i);        }                return hs;    }        public static long log2(long N)    {    	long result = (long)(Math.log(N) / Math.log(2));         return result;    }    	public static void main(String args[]) throws UnknownHostException, IOException, ClassNotFoundException, SQLException	{		FastReader sc = new FastReader();				PrintWriter out = new PrintWriter(System.out, true);				int t = sc.nextInt();//		int t = 1;				HashMap<String, Integer> hm = new HashMap<String, Integer>();	//		hm.put("a", 0);//		System.out.println(hm.containsKey("a"));		while(t-->0)		{			String s = sc.next();			if(hm.containsKey(s))			{				int freq = hm.get(s);				out.println(s + freq);				hm.put(s, freq+1);			}			else			{				hm.put(s, 1);				out.println("OK");			}					}				out.close();	}		public static int getIndex(int element, int temp[])	{		int i = 0;				for(i=0; i<temp.length; i++)		{			if(temp[i] == element) break;		}				return i+1;	}} class Num implements Comparable<Num> {    int n, b;     public Num (int n) {        this.n = n;        b = n&(-n);    }     @Override    public int compareTo(Num other) {        return other.b-this.b;    }} class pair implements Comparator<pair>{    private int first;    private int second;        pair(int _v, int _w) { first = _v; second = _w; }        pair() {}        int getfirst() { return first; }    int getsecond() { return second; }        public int compare(pair pair1, pair pair2)     {         if (pair1.second < pair2.second)             return -1;         if (pair1.second > pair2.second)             return 1;         return 0;     } } class Node implements Comparator<Node>{    private int v;    private int weight;        Node(int _v, int _w) { v = _v; weight = _w; }        Node() {}        int getV() { return v; }    int getWeight() { return weight; }        @Override    public int compare(Node node1, Node node2)     {         if (node1.weight < node2.weight)             return -1;         if (node1.weight > node2.weight)             return 1;         return 0;     } } class NewNode {	private int u;    private int v;    private int weight;        NewNode(int _u, int _v, int _w) { u = _u; v = _v; weight = _w; }        NewNode() {}        int getV() { return v; }    int getU() { return u; }    int getWeight() { return weight; } } class Graph{	// sample input tree	/*	 	 13 12	 1 2	 1 3	 1 13	 2 5	 3 4	 5 6	 5 7	 5 8	 8 12	 4 9	 4 10	 10 11	  	 */		// input	static class FastReader {        BufferedReader br;        StringTokenizer st;         public FastReader()        {            br = new BufferedReader(                new InputStreamReader(System.in));        }         String next()        {            while (st == null || !st.hasMoreElements()) {                try {                    st = new StringTokenizer(br.readLine());                }                catch (IOException e) {                    e.printStackTrace();                }            }            return st.nextToken();        }         int nextInt() { return Integer.parseInt(next()); }         long nextLong() { return Long.parseLong(next()); }         double nextDouble()        {            return Double.parseDouble(next());        }         String nextLine()        {            String str = "";            try {                str = br.readLine();            }            catch (IOException e) {                e.printStackTrace();            }            return str;        }    }	// input end	FastReader sc = new FastReader();		// graph    public static ArrayList<ArrayList<Integer>> graph = new ArrayList<>();    public static int[] arr;    public static ArrayList<Integer> ls = new ArrayList<Integer>();    public static int vertex;    public static int edges;    public static int[] degree;    public static int[] depth;    public static int[] sum;    public static int[] eve;    public static int[] height;    public static int[] parent;    public static int[] count;    public static boolean vis[];    public static int dx[] = {1, -1, 0, 0};    public static int dy[] = {0, 0, 1, -1};    public static int dist[];    ArrayList<NewNode> bellmangraph = new ArrayList<NewNode>();    public static int matrix[][];        public static int query;        public static ArrayList<ArrayList<Node> > weighted_graph = new ArrayList<ArrayList<Node> >();    // graph end    //    6 7 //    0 1 5 //    0 2 10 //    0 3 100 //    1 3 50 //    1 4 200//    3 4 250//    4 5 50        public void weighted_input()    {    	vertex = sc.nextInt();    	    	edges = sc.nextInt();    	    	parent = new int[vertex];    	    	Arrays.fill(parent, -1);    	    	for(int i=0; i<vertex; i++)		{			weighted_graph.add(new ArrayList<Node>());		}    	    	for(int i=0; i<edges; i++)		{			int a = sc.nextInt();			int b = sc.nextInt();			int w = sc.nextInt();						a = a-1;			b = b-1;						weighted_graph.get(a).add(new Node(b,w));			weighted_graph.get(b).add(new Node(a,w));		}    }        public static void shortestPath(int s)    {    	int N = vertex;    	        dist = new int[N];                for(int i = 0;i<N;i++) dist[i] = 100000000;        dist[s] = 0;                 PriorityQueue<Node> pq = new PriorityQueue<Node>(N, new Node());        pq.add(new Node(s, 0));                while(pq.size() > 0) {            Node node = pq.poll();                        for(Node it: weighted_graph.get(node.getV())) {                if(dist[node.getV()] + it.getWeight() < dist[it.getV()]) {                    dist[it.getV()] = dist[node.getV()] + it.getWeight();                    parent[it.getV()] = node.getV();                    pq.add(new Node(it.getV(), dist[it.getV()]));                }            }        }    }        // normal input	public void input()	{		vertex = sc.nextInt();		//		edges = sc.nextInt();				degree = new int[vertex];		depth = new int[vertex];		sum = new int[vertex];		eve = new int[vertex];		height = new int[vertex];		parent = new int[vertex];		vis = new boolean[vertex];		//		weight of vertex//		for(int i=0; i<vertex; i++)//		{//			int f = sc.nextInt();//			ls.add(f);//		}				for(int i=0; i<vertex; i++)		{			vis[i] = false;		}				for(int i=0; i<vertex; i++)		{			graph.add(new ArrayList<Integer>());		}				for(int i=0; i<edges; i++)		{			int a = sc.nextInt();			int b = sc.nextInt();						a = a-1;			b = b-1;						graph.get(a).add(b);			graph.get(b).add(a);						degree[a] = degree[a] + 1;			degree[b] = degree[b] + 1;		}	}		// normal input		public void tree_input()		{			vertex = sc.nextInt();			//			edges = sc.nextInt();						degree = new int[vertex];			depth = new int[vertex];			sum = new int[vertex];			eve = new int[vertex];			height = new int[vertex];			parent = new int[vertex];			vis = new boolean[vertex];			//			weight of vertex//			for(int i=0; i<vertex; i++)//			{//				int f = sc.nextInt();//				ls.add(f);//			}						for(int i=0; i<vertex; i++)			{				vis[i] = false;			}						for(int i=0; i<vertex; i++)			{				graph.add(new ArrayList<Integer>());			}						for(int i=0; i<vertex-1; i++)			{				int a = sc.nextInt();				int b = sc.nextInt();								a = a-1;				b = b-1;								graph.get(a).add(b);				graph.get(b).add(a);								degree[a] = degree[a] + 1;				degree[b] = degree[b] + 1;			}		}			// normal bfs	public static ArrayList<Integer> bfs(int v, ArrayList<ArrayList<Integer>> graph, int arr[])	{		ArrayList<Integer> bfs = new ArrayList<>();				boolean vis[] = new boolean[v];		Queue<Integer> q = new LinkedList<>();				q.add(0);		vis[0] = true;				while(!q.isEmpty())		{			Integer node = q.poll();			bfs.add(node);						for(Integer it : graph.get(node))			{				if(vis[it] == false)				{					vis[it] = true;					q.add(it);				}			}		}				return bfs;	}		public static void dfs(int v, int par)	{		parent[v] = par;		for(int child : graph.get(v))		{			if(child == par) continue;			depth[child] = depth[v] + 1;			dfs(child,v);		}	}		public static int getDepth()	{		int max_depth = -1;		int max_d_node = 0;				for(int i=0; i<vertex; i++)		{			if(max_depth < depth[i])			{				max_depth = depth[i];				max_d_node = i;			}			depth[i] = 0;		}				dfs(max_d_node,-1);				max_depth = -1;				for(int i=0; i<vertex; i++)		{			if(max_depth < depth[i])			{				max_depth = depth[i];			}		}				return max_depth;	}		public static ArrayList<Integer> path(int v)	{		ArrayList<Integer> ans = new ArrayList<Integer>();				while(v != -1)		{			ans.add(v);			v = parent[v];		}				Collections.reverse(ans);				return ans;	}		public static int getLCA(int x, int y)	{		ArrayList<Integer> path_x = path(x);		ArrayList<Integer> path_y = path(y);				int mn_ln = Math.min(path_x.size(), path_y.size());				int lca = -1;		for(int i=0; i<mn_ln; i++)		{			if(path_x.get(i) == path_y.get(i))			{				lca = path_x.get(i);			}			else			{				break;			}		}				return lca;	}		// normal dfs	public static ArrayList<Integer> dfs()	{		ArrayList<Integer> dfs = new ArrayList<Integer>();				boolean vis[] = new boolean[vertex];		sum = new int[vertex];		eve = new int[vertex];				Arrays.fill(vis, false);		Arrays.fill(depth, 0);		Arrays.fill(sum, 0);		Arrays.fill(eve, 0);		Arrays.fill(height, 0);				for(int i=0; i<vertex; i++)		{			if(!vis[i])			{				dfsUtil(i, -1, vis, dfs, sum, eve);			}		}				System.out.println(sum[0]);		System.out.println(eve[0]);		System.out.println(depth[8]);		System.out.println(height[4]);				return dfs;	}		public static  void dfsUtil(int node, int parent, boolean vis[], ArrayList<Integer> dfs, int sum[], int eve[])	{		// take action on vertex after entering vertex		//		if(graph.get(node).size() == 1 && graph.get(node).get(0) == parent)//		{//			leaf node//		}		dfs.add(node);		vis[node] = true;		sum[node] += (node+1);		if((node+1) % 2 == 0) eve[node]++;				for(Integer it : graph.get(node))		{			// take action on child node before entering child node			if(vis[it] == false)			{				depth[it] = depth[node] + 1;								dfsUtil(it, node, vis, dfs, sum, eve);								// now child node is exited take action								height[node] = Math.max(height[node], height[it]+1);				sum[node] = sum[node] + sum[it];				eve[node] = eve[node] + eve[it];			}		}		// take action before exiting vertex	}		public void isCyclic() {        int topo[] = new int[vertex];        int indegree[] = new int[vertex];                //finding indegree        for(int i = 0;i<vertex;i++) {            for(Integer it: graph.get(i)) {                indegree[it]++;            }        }                Queue<Integer> q = new LinkedList<Integer>();        for(int i = 0;i<vertex;i++) {            //adding nodes to queue with indegree = 0            if(indegree[i] == 0) {                q.add(i);            }        }                int cnt = 0;        int ind=0;                while(!q.isEmpty()) {            Integer node = q.poll();            topo[ind++] = node;            cnt++;            //getting neighbour nodes of popped node            //and decreasing their             //indegree by1            for(Integer it: graph.get(node)) {                indegree[it]--;                if(indegree[it] == 0) {                    q.add(it);                }            }        }                //printing topological ordering of nodes        for (int i=0;i< topo.length;i++){            System.out.print(topo[i]+" ");        }        //        checks if graph is cyclic//        if(cnt == N) return false;//        return true;    }		static void findTopoSort(int node, Stack<Integer> st) {        vis[node] = true;         for(Integer it: graph.get(node)) {            if(vis[it] == false) {                findTopoSort(it, st);             }         }        st.push(node);     }    	static int[] topoSort() {        Stack<Integer> st = new Stack<Integer>();                  for(int i = 0;i<vertex;i++) {            if(vis[i] == false) {                findTopoSort(i, st);            }        }                int topo[] = new int[vertex];        int ind = 0;         while(!st.isEmpty()) {            topo[ind] = st.pop();            ind++;        }//         for(int i = 0;i<N;i++) System.out.println(topo[i] + " ");         return topo;     }		public static void primsAlgo()    {        int key[] = new int[vertex];        int parent[] = new int[vertex];         boolean mstSet[] = new boolean[vertex];         for(int i = 0;i<vertex;i++) {        	key[i] = 100000000;         	mstSet[i] = false;         }         PriorityQueue<Node> pq = new PriorityQueue<Node>(vertex, new Node());         key[0] = 0;        parent[0] = -1;         pq.add(new Node(key[0], 0)); 		// Run the loop till all the nodes have been visited	    // because in the brute code we checked for mstSet[node] == false while computing the minimum	    // but here we simply take the minimal from the priority queue, so a lot of times a node might be taken twice	    // hence its better to keep running till all the nodes have been taken. 	    // try the following case: 	    // Credits: Srejan Bera//	     6 7 //	     0 1 5 //	     0 2 10 //	     0 3 100 //	     1 3 50 //	     1 4 200//	     3 4 250//	     4 5 50         while(!pq.isEmpty()) {        	int u = pq.poll().getV();        	mstSet[u] = true;                	for(Node it: weighted_graph.get(u)) {        		if(mstSet[it.getV()] == false && it.getWeight() < key[it.getV()]) {        			parent[it.getV()] = u;         			key[it.getV()] = it.getWeight();         			pq.add(new Node(it.getV(), key[it.getV()]));        		}        	}        }         for(int i = 1;i<vertex;i++) {        	System.out.println(parent[i] + " - " + i);         }    }		void bellmaninput()	{		vertex = sc.nextInt();				edges = sc.nextInt();				for(int i=0; i<edges; i++)		{			int a = sc.nextInt();			int b = sc.nextInt();			int w = sc.nextInt();						a--;			b--;						bellmangraph.add(new NewNode(a,b,w));		}	}		void bellmanFord(int src)    {		ArrayList<NewNode> edges = bellmangraph;		int N = vertex;		        dist = new int[N];        for(int i = 0;i<N;i++) dist[i] = 10000000;          dist[src] = 0;     	for(int i = 1;i<=N-1;i++) {    		for(NewNode node : edges) {    			if(dist[node.getU()] + node.getWeight() < dist[node.getV()]) {    				dist[node.getV()] = dist[node.getU()] + node.getWeight();     			}    		}    	}     	int fl = 0;     	for(NewNode node: edges) {    		if(dist[node.getU()] + node.getWeight() < dist[node.getV()]) {    			fl = 1;    			System.out.println("Negative Cycle");     			break;    		}    	}     	if(fl == 0) {    		for(int i = 0;i<N;i++) {    			System.out.println(i + " " + dist[i]);     		}    	}    }		public void floydWarshall_input()	{		vertex = sc.nextInt();				edges = sc.nextInt();				query = sc.nextInt();				matrix = new int[vertex][vertex];				for (int i = 0; i < vertex; i++) {            for (int j = 0; j < vertex; j++) {                matrix[i][j] = -1;            }        }				for(int i=0; i<edges; i++)		{			int a = sc.nextInt();			int b = sc.nextInt();						int weight = sc.nextInt();						a--;			b--;						matrix[a][b] = weight;			matrix[b][a] = weight;		}				floyadWarshal_shortest_distance();				for(int i=0; i<query; i++)		{			int a = sc.nextInt();			int b = sc.nextInt();						a--;			b--;						System.out.println(matrix[a][b]);		}	}		public void floyadWarshal_shortest_distance() {        int n = matrix.length;        for (int i = 0; i < n; i++) {            for (int j = 0; j < n; j++) {                if (matrix[i][j] == -1) {                    matrix[i][j] = (int)(1e9);                }                if (i == j) matrix[i][j] = 0;            }        }         for (int k = 0; k < n; k++) {            for (int i = 0; i < n; i++) {                for (int j = 0; j < n; j++) {                    matrix[i][j] = Math.min(matrix[i][j],                                            matrix[i][k] + matrix[k][j]);                }            }        }         for (int i = 0; i < n; i++) {            for (int j = 0; j < n; j++) {                if (matrix[i][j] == (int)(1e9)) {                    matrix[i][j] = -1;                }            }        }    }		public static void dfs(int node, int parent, int vis[], int tin[], int low[], ArrayList<ArrayList<Integer>> adj, int timer) {		vis[node] = 1; 		tin[node] = low[node] = timer++;  		for(Integer it: adj.get(node)) {			if(it == parent) continue;  			if(vis[it] == 0) {				dfs(it, node, vis, tin, low, adj, timer); 				low[node] = Math.min(low[node], low[it]);  				if(low[it] > tin[node]) {					System.out.println(it + " " +node); 				}			} else {				low[node] = Math.min(low[node], tin[it]); 			}		}	}    public static void printBridges(ArrayList<ArrayList<Integer>> adj, int n)    {        int vis[] = new int[n];         int tin[] = new int[n];        int low[] = new int[n];          int timer = 0;         for(int i = 0;i<n;i++) {        	if(vis[i] == 0) {        		dfs(i, -1, vis, tin, low, adj, timer);         	}        }    }        // articulation point    private void dfs_art(int node, int parent, int vis[], int tin[], int low[], ArrayList<ArrayList<Integer>> adj, int timer, int isArticulation[]) {		vis[node] = 1; 		tin[node] = low[node] = timer++; 		int child = 0; 		for(Integer it: adj.get(node)) {			if(it == parent) continue;  			if(vis[it] == 0) {				dfs_art(it, node, vis, tin, low, adj, timer, isArticulation); 				low[node] = Math.min(low[node], low[it]);  				if(low[it] >= tin[node] && parent != -1) {					isArticulation[node] = 1;  				}				child++; 			} else {				low[node] = Math.min(low[node], tin[it]); 			}		}		if(parent != -1 && child > 1) isArticulation[node] = 1;  	}    void printArticulation(ArrayList<ArrayList<Integer>> adj, int n)    {        int vis[] = new int[n];         int tin[] = new int[n];        int low[] = new int[n];                 int isArticulation[] = new int[n];                int timer = 0;         for(int i = 0;i<n;i++) {        	if(vis[i] == 0) {        		dfs_art(i, -1, vis, tin, low, adj, timer, isArticulation);         	}        }                for(int i = 0;i<n;i++) {            if(isArticulation[i] == 1) System.out.println(i);         }    }}