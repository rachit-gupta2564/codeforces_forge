import java.util.*; // import org.omg.Messaging.SyncScopeHelper; import java.io.*;  // import javax.annotation.processing.SupportedSourceVersion;// import javax.swing.plaf.synth.SynthDesktopIconUI;// import javax.swing.plaf.synth.SynthOptionPaneUI;// import javax.swing.plaf.synth.SynthDesktopIconUI;// import javax.annotation.processing.SupportedSourceVersion;// import java.lang.classfile.constantpool.IntegerEntry;// import java.lang.reflect.Array;// import java.lang.classfile.instruction.StackInstruction; public class Main {    static class Data implements Comparable<Data>{        int val;        int modi;        int idx;        public Data(int val, int modi, int idx){            this.modi = modi;            this.val = val;            this.idx = idx;        }        @Override        public int compareTo(Data p1){            return (int)(p1.val-this.val);        }    }    static class Val implements Comparable<Val>{        long x;        long y;        public Val(long x, long y){            this.x = x;            this.y = y;        }        @Override        public int compareTo(Val v){            if(this.x<=v.x) return 1;            return -1;        }    }        public static PP.Reader cs = new PP.Reader(System.in);    // public static long ans[];    // public static BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));    // public static long[][] ncr = new long[51][51];    public static long[] fact;    public static void main(String[] args) throws IOException{        int tests = cs.nextInt();        while(tests>0){            tests--;            solve();        }        // writer.flush();        // writer.close();    }    public static long mod = 1000000000 +7;    public static long MOD = 998244353; // type it    public static ArrayList<Integer> graph[];    public static SegmentTreeIdx st;    public static void solve() throws IOException{        int n = cs.nextInt();        int l = 1;        int r = n;        while (l<r) {            System.out.println("? "+l+" "+r);            long sum = cs.nextLong();            int min = l;            int max = r;            int half = 0;            while (min<=max) {                int mid = (min+max)/2;                System.out.println("? "+l+" "+mid);                long inn = cs.nextLong();                if(sum/2 == inn){                    half = mid;                    break;                }                else if(inn<sum/2) min = mid+1;                else max = mid-1;            }            // System.out.println(l+" - "+r);            // System.out.println(half+"--h");            if(half-l+1>=r-half) l = half+1;            else r=half;            // System.out.println(l+" - "+r);        }        System.out.println("? "+l+" "+r);        System.out.println("! "+cs.nextLong());     }              public static int kth_ancestor(int[][] binpar,int node,int k){        for(int i=0;i<21;i++){            int bitset = (k>>i)&1;            if(bitset ==1){                node = binpar[i][node];            }            if(node == -1) return -2;        }        return node;    }      public static long gcd(long a,long b){        // System.out.println(a+" "+b);        long c = Math.min(a,b);        long d = Math.max(a,b);        if(d%c==0) return c;        return gcd(c,d%c);    }    public static long divmod(long a,long b,long m){   //claculate (a/b)%m        a = a%m;b = b%m;  // Include if not working        long inv =  powermod(b, m-2, m);        return (inv*a)%m;    }    static long powermod(long x, long y, long p) //calculate (x^y)%p    {        long res = 1;        x = x % p;         while (y > 0) {            if ((y & 1) > 0)                res = (res * x) % p;            y = y >> 1;             x = (x * x) % p;        }        return res;    }} class Fenwick{    /*     Note this works on 1 based indexing;    update(2,4) will do arr[1] += 4;    prefixsum(2) gives  sum of arr[0]+arr[1];    rangesum(3,5) gives sum of arr[2]+arr[3]+arr[4];    */     public static long mod = 1000000000 + 7;    long fenarr[];    public Fenwick(int size){        fenarr = new long[size+1];    }    public Fenwick(long arr[]){        fenarr = new long[arr.length+1];        for(int i=1;i<=arr.length;i++) update(i, arr[i-1]);    }    public void update(int idx,long change){        while(idx<fenarr.length){            fenarr[idx] = (fenarr[idx] + change)%mod;            idx += (idx&-idx);        }    }    // Prefix sum query: sum of [1..idx]    public long prefixSum(int idx) {        long ans = 0;        while (idx > 0) {            ans = (ans + fenarr[idx]) % mod;            idx -= (idx & -idx);        }        return ans;    }     // Range sum query: sum of [l..r], 1-based    public long rangeSum(int l, int r) {        if (l > r) return 0;        return (prefixSum(r) - prefixSum(l - 1) + mod) % mod;    }}class SparseTable{    /*      *Gives RangeMin, RangeMax in O(1). Preprcess cost O(nlogn).     * It is 0  based. So do  Query like object.rangeMin(1,3) for min(arr[1],arr[2],arr[3]);     */        int n;        int row;        public long[][] sparsetable_min;        public long[][] sparsetable_max;        public SparseTable(long[] arr){            n = arr.length;            row = 0;            while((1<<row)<n) row++;            row++;            sparsetable_min = new long[row][n];            sparsetable_max = new long[row][n];            for(int i=0;i<n;i++){                sparsetable_min[0][i] = arr[i];                sparsetable_max[0][i] = arr[i];            }            for(int i=1;i<row;i++){                for(int j=0;(1<<i)-1+j<n;j++){                    sparsetable_max[i][j] = Math.max(sparsetable_max[i-1][j],sparsetable_max[i-1][j+(1<<i)/2]);                    sparsetable_min[i][j] = Math.min(sparsetable_min[i-1][j],sparsetable_min[i-1][j+(1<<i)/2]);                }            }        }        public long rangeMin(int l,int r){            if(l == r) return sparsetable_min[0][l];            int len = r-l+1;            int closepow = 0;            while((1<<closepow)<len) closepow++;            if((1<<closepow) == len) return sparsetable_min[closepow][l];            closepow--;            return Math.min(sparsetable_min[closepow][l],sparsetable_min[closepow][r-(1<<closepow)+1]);        }        public long rangeMax(int l,int r){            if(l == r) return sparsetable_max[0][l];            int len = r-l+1;            int closepow = 0;            while((1<<closepow)<len) closepow++;            if((1<<closepow) == len) return sparsetable_max[closepow][l];            closepow--;            return Math.max(sparsetable_max[closepow][l],sparsetable_max[closepow][r-(1<<closepow)+1]);        }    }class PP {    static String IN = "%s";    static String OUT = "%s";     static class Reader {        BufferedReader br;        StringTokenizer st;         Reader(InputStream is) {            br = new BufferedReader(new InputStreamReader(is));        }         String next() {            try {                while (st == null || !st.hasMoreTokens())                    st = new StringTokenizer(br.readLine());                return st.nextToken();            } catch (Exception ignored) {            }            return null;        }         int nextInt() {            return Integer.parseInt(next());        }         long nextLong() {            return Long.parseLong(next());        }         double nextDouble() {            return Double.parseDouble(next());        }    }} class SegmentTreeIdx {    private final int n;    private final int[][] tree; // [][0]=minIdx, [][1]=maxIdx    private final long[] arr;     public SegmentTreeIdx(long[] input) {        this.n = input.length;        this.arr = new long[n];        System.arraycopy(input, 0, this.arr, 0, n);        this.tree = new int[4 * Math.max(1, n)][2];        if (n > 0) build(1, 0, n - 1);    }     private void build(int node, int l, int r) {        if (l == r) {            tree[node][0] = l;            tree[node][1] = l;            return;        }        int mid = l + (r - l) / 2;        build(node << 1, l, mid);        build(node << 1 | 1, mid + 1, r);        pull(node);    }     private void pull(int node) {        int l = node << 1, r = node << 1 | 1;         int lmin = tree[l][0], rmin = tree[r][0];        int lmax = tree[l][1], rmax = tree[r][1];         tree[node][0] = (arr[lmin] <= arr[rmin]) ? lmin : rmin;        tree[node][1] = (arr[lmax] >= arr[rmax]) ? lmax : rmax;    }     // -------- MIN INDEX QUERY --------    public int rangeMinIndex(int l, int r) {        if (l < 0 || r >= n || l > r) throw new IllegalArgumentException();        return queryMin(1, 0, n - 1, l, r);    }     private int queryMin(int node, int nl, int nr, int ql, int qr) {        if (ql > nr || qr < nl) return -1;        if (ql <= nl && nr <= qr) return tree[node][0];         int mid = nl + (nr - nl) / 2;        int a = queryMin(node << 1, nl, mid, ql, qr);        int b = queryMin(node << 1 | 1, mid + 1, nr, ql, qr);         if (a == -1) return b;        if (b == -1) return a;        return (arr[a] <= arr[b]) ? a : b;    }     // -------- MAX INDEX QUERY --------    public int rangeMaxIndex(int l, int r) {        if (l < 0 || r >= n || l > r) throw new IllegalArgumentException();        return queryMax(1, 0, n - 1, l, r);    }     private int queryMax(int node, int nl, int nr, int ql, int qr) {        if (ql > nr || qr < nl) return -1;        if (ql <= nl && nr <= qr) return tree[node][1];         int mid = nl + (nr - nl) / 2;        int a = queryMax(node << 1, nl, mid, ql, qr);        int b = queryMax(node << 1 | 1, mid + 1, nr, ql, qr);         if (a == -1) return b;        if (b == -1) return a;        return (arr[a] >= arr[b]) ? a : b;    }     public void update(int idx, long val) {        updateNode(1, 0, n - 1, idx, val);        arr[idx] = val;    }     private void updateNode(int node, int nl, int nr, int pos, long val) {        if (nl == nr) {            tree[node][0] = nl;            tree[node][1] = nl;            return;        }        int mid = nl + (nr - nl) / 2;        if (pos <= mid) updateNode(node << 1, nl, mid, pos, val);        else updateNode(node << 1 | 1, mid + 1, nr, pos, val);        pull(node);    }} class Trie {    Trie[] child;    int count;    // boolean isEnd;    public Trie() {        child = new Trie[26];        count = 0;        // count = new int[26];        // isEnd = false;    }     public void insert(String word) {        if(child[word.charAt(0)-'a'] == null) child[word.charAt(0)-'a'] = new Trie();        count++;        Trie curr = child[word.charAt(0)-'a'] ;        for(int i=1;i<word.length();i++){            curr.count++;            if(curr.child[word.charAt(0)-'a'] == null) curr.child[word.charAt(0)-'a'] = new Trie();            curr = curr.child[word.charAt(i)-'a'];         }                curr.count++;        // curr.isEnd = true;    }     public int countWordsEqualTo(String word) {        if(child[word.charAt(0)-'a'] == null) return 0;        Trie curr = child[word.charAt(0)-'a'];        for(int i=1;i<word.length();i++){            if(child[word.charAt(0)-'a'] == null) return 0;            curr = curr.child[word.charAt(i)-'a'];         }        int total = curr.count;        for(int i=0;i<26;i++){            if(curr.child[i] == null) continue;            total -= curr.child[i].count;        }        return count;    }     public int countWordsStartingWith(String prefix) {        if(child[prefix.charAt(0)-'a'] == null) return 0;        Trie curr = child[prefix.charAt(0)-'a'] ;        for(int i=1;i<prefix.length();i++){            if(child[prefix.charAt(0)-'a'] == null) return 0;            curr = curr.child[prefix.charAt(i)-'a'];         }        return curr.count;    }     public void erase(String word) {        count--;        Trie curr = child[word.charAt(0)-'a'] ;        for(int i=1;i<word.length();i++){            curr.count--;            if(child[word.charAt(0)-'a'] == null) child[word.charAt(0)-'a'] = new Trie();            curr = curr.child[word.charAt(i)-'a'];         }        curr.count--;    }} /** * Our Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * int param_2 = obj.countWordsEqualTo(word); * int param_3 = obj.countWordsStartingWith(prefix); * obj.erase(word); */